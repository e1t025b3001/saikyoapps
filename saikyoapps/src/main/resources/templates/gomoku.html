<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <title th:text="#{game.gomoku.title}">五目並べ（Gomoku）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #boardWrap {
      width: 600px;
      margin: 16px auto;
    }

    canvas {
      background: #f5deb3;
      display: block;
      margin: 0 auto;
      border: 1px solid #333;
    }

    #info {
      text-align: center;
      margin-top: 8px;
    }

    #controls {
      text-align: center;
      margin-top: 12px;
    }

    button {
      padding: 8px 12px;
    }

    /* 勝敗確認對話框樣式 */
    #resultDialog {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }

    #resultDialog>div {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      width: 320px;
      margin: 120px auto;
      text-align: center;
    }

    .spectateBanner {
      max-width: 600px;
      margin: 10px auto 0;
      padding: 10px 12px;
      border: 1px solid #ddd;
      background: #fafafa;
      color: #333;
      display: none;
    }
  </style>
</head>

<body th:attr="data-game=${game}">
  <h1 style="text-align:center;" th:text="#{game.gomoku.title}">五目並べ</h1>

  <div id="spectateBanner" class="spectateBanner"></div>

  <div id="controls">
    <input type="hidden" id="pageGame" th:value="${game}" />
  </div>

  <div id="surrenderWrap" style="text-align:center;margin-top:8px;">
    <button id="surrenderBtn" th:text="#{game.action.forfeit}">投降</button>
  </div>

  <!-- 勝敗確認ダイアログ -->
  <div id="resultDialog"
    style="display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.5);">
    <div style="background:#fff;padding:16px;border-radius:6px;width:320px;margin:120px auto;text-align:center;">
      <div id="resultDialogText" style="margin-bottom:12px;font-weight:bold;color:#b00;"></div>
      <button id="resultConfirmBtn" th:text="#{game.action.confirmAndReturn}">確認並返回大廳</button>
    </div>
  </div>

  <div id="boardWrap">
    <canvas id="gomokuBoard" width="600" height="600"></canvas>
    <div id="info">
      <div id="turnInfo" th:text="#{game.turn.waiting}">等待中...</div>
      <div id="result" style="color:darkred;font-weight:bold;"></div>
    </div>
  </div>

  <script th:inline="javascript">
    /*<![CDATA[*/
    const game = /*[[${game}]]*/ 'gomoku';
    /*]]>*/

    (function () {
      // 簡潔版 Gomoku 前端
      const origin = window.location.origin;
      const size = 15;
      const canvas = document.getElementById('gomokuBoard');
      const ctx = canvas.getContext('2d');
      const cssW = canvas.width,
        cssH = canvas.height;
      const DPR = window.devicePixelRatio || 1;
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.scale(DPR, DPR);
      const cell = cssW / (size - 1);

      let board = Array.from({ length: size }, () => Array(size).fill(0));
      let myColor = null; // 1 black, 2 white
      let currentTurn = 1; // 1 black, 2 white
      let finished = false;
      let gameId = null;
      let matchTimer = null;
      let gameTimer = null;

      let playerBlack = null;
      let playerWhite = null;
      let lastFinishedShown = false;

      function drawBoard() {
        ctx.clearRect(0, 0, cssW, cssH);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i < size; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * cell);
          ctx.lineTo(cssW, i * cell);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(i * cell, 0);
          ctx.lineTo(i * cell, cssH);
          ctx.stroke();
        }
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const v = board[r][c];
            if (v !== 0) drawStone(r, c, v);
          }
        }
      }

      function drawStone(r, c, v) {
        const x = c * cell,
          y = r * cell;
        ctx.beginPath();
        ctx.arc(x, y, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.stroke();
      }

      function posToCell(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const rx = clientX - rect.left,
          ry = clientY - rect.top;
        const c = Math.round(rx / cell),
          r = Math.round(ry / cell);
        return { r, c };
      }

      function updateTurnText() {
        const el = document.getElementById('turnInfo');
        if (finished) return;
        if (!myColor) {
          el.textContent = '観戦中...';
          return;
        }
        el.textContent = currentTurn === myColor ? 'あなたの番' : '相手の番';
      }

      function showResultText(t) {
        document.getElementById('result').textContent = t;
      }

      // 結果ダイアログ（共通）
      function showResultDialogText(text, backToSpectate) {
        finished = true;
        if (matchTimer) { clearInterval(matchTimer); matchTimer = null; }
        if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
        const dlgText = document.getElementById('resultDialogText');
        dlgText.textContent = text;
        const dlg = document.getElementById('resultDialog');
        dlg.style.display = 'block';
        const confirmBtn = document.getElementById('resultConfirmBtn');
        confirmBtn.onclick = function () {
          location.href = backToSpectate ? '/gomoku/spectate' : '/';
        };
        setTimeout(() => {
          if (dlg.style.display !== 'none') {
            location.href = backToSpectate ? '/gomoku/spectate' : '/';
          }
        }, 10000);
      }

      // 安全な fetch。{ok, status, json} を返す
      function fetchSafe(url, opts) {
        return fetch(url, opts).then(res => {
          const status = res.status;
          const contentType = res.headers.get('content-type') || '';
          if (contentType.includes('application/json')) {
            return res.json().then(j => ({ ok: res.ok, status: status, json: j }));
          }
          return { ok: res.ok, status: status, json: null };
        });
      }

      function getQueryParam(name) {
        const u = new URL(window.location.href);
        return u.searchParams.get(name);
      }

      function updateSpectateBanner() {
        const banner = document.getElementById('spectateBanner');
        if (!banner) return;

        const isSpectator = !myColor;
        if (!isSpectator) {
          banner.style.display = 'none';
          return;
        }

        const pb = playerBlack || '?';
        const pw = playerWhite || '?';
        banner.textContent = `観戦中: ${pb}（黒） vs ${pw}（白） / GAME_ID=${gameId}`;
        banner.style.display = 'block';
      }

      function showFinishedDialogForSpectator(j) {
        if (lastFinishedShown) return;
        lastFinishedShown = true;

        const winSide = j && j.winner ? (j.winner === 'black' ? '黒' : '白') : '不明';
        showResultDialogText(`対局終了（勝者: ${winSide}）`, true);
      }

      // fallback: サーバが 404/400 等を返した場合は終了扱いとして戻す
      function finishFallback() {
        if (matchTimer) { clearInterval(matchTimer); matchTimer = null; }
        if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
        fetchSafe(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
          .then(r => {
            let text = '対局が終了しました';
            if (r && r.json) {
              const s = r.json.status;
              if (s === 'lobby') text = '対局が終了しました（ロビーへ戻ります）';
            }
            showResultDialogText(text, false);
          }).catch(e => {
            console.warn('finishFallback error', e);
            showResultDialogText('対局が終了しました', false);
          });
      }

      // 點擊處理：只在 server 成功後更新
      canvas.addEventListener('click', function (e) {
        if (finished) return;
        const { r, c } = posToCell(e.clientX, e.clientY);
        if (r < 0 || r >= size || c < 0 || c >= size) return;
        if (board[r][c] !== 0) return;
        if (!gameId) { console.warn('no gameId yet'); return; }
        if (!myColor || currentTurn !== myColor) { console.warn('not your turn'); return; }

        // 禁用點擊
        canvas.style.pointerEvents = 'none';
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '/move', {
          method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ x: c, y: r })
        }).then(resp => {
          if (!resp.ok) {
            console.warn('move resp not ok', resp.status);
            finishFallback();
            return;
          }
          const j = resp.json || {};
          if (j.board) board = j.board;
          if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
          if (j.finished) {
            finished = true;
            if (!myColor) {
              showFinishedDialogForSpectator(j);
            } else if (j.winner) {
              const text = (j.winner === 'black')
                ? (myColor === 1 ? MSG_YOUR_WIN : MSG_YOUR_LOSE)
                : (myColor === 2 ? MSG_YOUR_WIN : MSG_YOUR_LOSE);
              showResultDialogText(text, false);
            } else {
              showResultDialogText(MSG_GAME_FINISHED, false);
            }
          }
          drawBoard();
          updateTurnText();
        }).catch(err => { console.error('move error', err); finishFallback(); }).finally(() => { canvas.style.pointerEvents = ''; });
      });

      function startMatchPoll() {
        matchTimer = setInterval(() => {
          fetchSafe(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
            .then(res => {
              if (!res || !res.ok) return;
              const j = res.json || {};
              if (!j) return;
              if (j.status === 'lobby') {
                clearInterval(matchTimer);
                if (gameTimer) clearInterval(gameTimer);
                location.href = '/';
                return;
              }
              if (j.status === 'playing' && j.gameId) {
                if (!gameId) startGameLoop(j.gameId);
              }
            }).catch(e => { console.error('matching fetch', e); });
        }, 1000);
      }

      function startGameLoop(gid) {
        gameId = gid;

        const surrenderWrap = document.getElementById('surrenderWrap');

        // 立即取得一次遊戲狀態
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId), { cache: 'no-store', credentials: 'include' })
          .then(resp => {
            if (!resp.ok) { finishFallback(); return; }
            const j = resp.json || {};
            if (j.board) board = j.board;
            if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
            if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;

            playerBlack = j.playerBlack || null;
            playerWhite = j.playerWhite || null;
            if (j.finished) { finished = true; }

            if (!myColor && surrenderWrap) surrenderWrap.style.display = 'none';

            drawBoard();
            updateTurnText();
            updateSpectateBanner();

            if (j.finished && !myColor) {
              showFinishedDialogForSpectator(j);
            }
            if (j.finished && myColor) {
              const text = (j.winner === 'black')
                ? (myColor === 1 ? 'あなたの勝ち！' : 'あなたの負け...')
                : (myColor === 2 ? 'あなたの勝ち！' : 'あなたの負け...');
              showResultDialogText(text, false);
            }
          }).catch(e => { console.error('initial game fetch', e); finishFallback(); });

        gameTimer = setInterval(() => {
          fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '?_=' + Date.now(), { cache: 'no-store', credentials: 'include' })
            .then(resp => {
              if (!resp.ok) { finishFallback(); return; }
              const j = resp.json || {};
              if (j.board) board = j.board;
              if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
              if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
              playerBlack = j.playerBlack || playerBlack;
              playerWhite = j.playerWhite || playerWhite;
              if (j.finished) { finished = true; }

              if (!myColor && surrenderWrap) surrenderWrap.style.display = 'none';

              drawBoard();
              updateTurnText();
              updateSpectateBanner();

              if (j.finished) {
                if (!myColor) {
                  showFinishedDialogForSpectator(j);
                } else {
                  const text = (j.winner === 'black')
                    ? (myColor === 1 ? 'あなたの勝ち！' : 'あなたの負け...')
                    : (myColor === 2 ? 'あなたの勝ち！' : 'あなたの負け...');
                  showResultDialogText(text, false);
                }
              }
            }).catch(e => { console.error('game poll error', e); finishFallback(); });
        }, 1000);
      }

      document.getElementById('surrenderBtn').addEventListener('click', function () {
        if (!gameId) return alert('ゲームがまだ開始していません');
        if (!confirm('投降してロビーへ戻りますか？')) return;
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '/forfeit', { method: 'POST', credentials: 'include' })
          .then(resp => {
            if (!resp.ok) { finishFallback(); return; }
            const j = resp.json || {};
            const winner = j.winner;
            const text = (winner === 'black')
              ? (myColor === 1 ? 'あなたの勝ち！' : 'あなたの負け...')
              : (myColor === 2 ? 'あなたの勝ち！' : 'あなたの負け...');
            showResultDialogText(text, false);
          }).catch(e => { console.error('forfeit error', e); finishFallback(); });
      });

      // 初期化
      drawBoard();
      updateTurnText();

      // 観戦モード：URL matchId があれば matching/status を使わずに直接 startGameLoop
      const directGid = getQueryParam('matchId');
      if (directGid) {
        startGameLoop(directGid);
      } else {
        startMatchPoll();
      }

    })();
  </script>
</body>

</html>
