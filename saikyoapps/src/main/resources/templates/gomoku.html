<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <title>五目並べ（Gomoku）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #boardWrap {
      width: 600px;
      margin: 16px auto;
    }

    canvas {
      background: #f5deb3;
      display: block;
      margin: 0 auto;
      border: 1px solid #333;
    }

    #info {
      text-align: center;
      margin-top: 8px;
    }

    #controls {
      text-align: center;
      margin-top: 12px;
    }

    button {
      padding: 8px 12px;
    }

    /* 勝敗確認對話框樣式 */
    #resultDialog {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }

    #resultDialog>div {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      width: 320px;
      margin: 120px auto;
      text-align: center;
    }
  </style>
</head>

<body th:attr="data-game=${game}">
  <h1 style="text-align:center;">五目並べ</h1>

  <div id="controls">
    <input type="hidden" id="pageGame" th:value="${game}" />
  </div>

  <div style="text-align:center;margin-top:8px;">
    <button id="surrenderBtn">投降</button>
  </div>
  <!-- 勝敗確認ダイアログ -->
  <div id="resultDialog"
    style="display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.5);">
    <div style="background:#fff;padding:16px;border-radius:6px;width:320px;margin:120px auto;text-align:center;">
      <div id="resultDialogText" style="margin-bottom:12px;font-weight:bold;color:#b00;"></div>
      <button id="resultConfirmBtn">確認並返回大廳</button>
    </div>
  </div>

  <div id="boardWrap">
    <canvas id="gomokuBoard" width="600" height="600"></canvas>
    <div id="info">
      <div id="turnInfo">等待中...</div>
      <div id="result" style="color:darkred;font-weight:bold;"></div>
    </div>
  </div>

  <script th:inline="javascript">
    /*<![CDATA[*/
    const game = /*[[${game}]]*/ 'gomoku';
    /*]]>*/

    (function () {
      // 簡潔版 Gomoku 前端，參考 tictactoe.js 的結構
      const origin = window.location.origin;
      const size = 15;
      const canvas = document.getElementById('gomokuBoard');
      const ctx = canvas.getContext('2d');
      const cssW = canvas.width,
        cssH = canvas.height;
      const DPR = window.devicePixelRatio || 1;
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.scale(DPR, DPR);
      const cell = cssW / (size - 1);

      let board = Array.from({ length: size }, () => Array(size).fill(0));
      let myColor = null; // 1 black, 2 white
      let currentTurn = 1; // 1 black, 2 white
      let finished = false;
      let gameId = null;
      let matchTimer = null;
      let gameTimer = null;

      function drawBoard() {
        ctx.clearRect(0, 0, cssW, cssH);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i < size; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * cell);
          ctx.lineTo(cssW, i * cell);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(i * cell, 0);
          ctx.lineTo(i * cell, cssH);
          ctx.stroke();
        }
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const v = board[r][c];
            if (v !== 0) drawStone(r, c, v);
          }
        }
      }

      function drawStone(r, c, v) {
        const x = c * cell,
          y = r * cell;
        ctx.beginPath();
        ctx.arc(x, y, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.stroke();
      }

      function posToCell(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const rx = clientX - rect.left,
          ry = clientY - rect.top;
        const c = Math.round(rx / cell),
          r = Math.round(ry / cell);
        return { r, c };
      }

      function updateTurnText() {
        const el = document.getElementById('turnInfo');
        if (finished) return;
        if (!myColor) {
          el.textContent = '已開始遊戲，等待伺服器分配顏色與回合資訊...';
          return;
        }
        el.textContent = currentTurn === myColor ? '你的回合' : '對手的回合';
      }

      function showResultText(t) {
        document.getElementById('result').textContent = t;
      }

      // 輕量錯誤紀錄
      function simpleFetchJson(url, opts) {
        return fetch(url, opts).then(res => {
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return res.json();
        });
      }

      // 點擊處理：只在 server 成功後更新
      canvas.addEventListener('click', function (e) {
        if (finished) return;
        const { r, c } = posToCell(e.clientX, e.clientY);
        if (r < 0 || r >= size || c < 0 || c >= size) return;
        if (board[r][c] !== 0) return;
        if (!gameId) { console.warn('no gameId yet'); return; }
        if (!myColor || currentTurn !== myColor) { console.warn('not your turn'); return; }

        // 禁用點擊
        canvas.style.pointerEvents = 'none';
        simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId) + '/move', {
          method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ x: c, y: r })
        }).then(j => {
          if (j.board) board = j.board;
          if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
          if (j.finished) {
            finished = true;
            if (j.winner) showResultText(j.winner === 'black' ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...'));
            // 顯示確認對話框，直到玩家按下確認按鈕才返回大廳；若沒有動作，10 秒後自動返回
            const dlgText = document.getElementById('resultDialogText');
            dlgText.textContent = (j.winner === 'black') ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...');
            const dlg = document.getElementById('resultDialog');
            dlg.style.display = 'block';
            const confirmBtn = document.getElementById('resultConfirmBtn');
            confirmBtn.onclick = function () { location.href = '/'; };
            setTimeout(() => { if (dlg.style.display !== 'none') location.href = '/'; }, 10000);
          }
          drawBoard();
          updateTurnText();
        }).catch(err => { console.error('move error', err); }).finally(() => { canvas.style.pointerEvents = ''; });
      });

      // 輪詢 matching/status，拿到 gameId 後啟動 game 輪詢
      function startMatchPoll() {
        matchTimer = setInterval(() => {
          simpleFetchJson(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
            .then(j => {
              if (!j) return;
              if (j.status === 'lobby') { clearInterval(matchTimer); if (gameTimer) clearInterval(gameTimer); location.href = '/'; }
              if (j.status === 'playing' && j.gameId) { if (!gameId) startGameLoop(j.gameId); }
            }).catch(e => { console.error('matching fetch', e); });
        }, 1000);
      }

      function startGameLoop(gid) {
        gameId = gid;
        console.log('start game', gid);
        // 立即取得一次遊戲狀態
        simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId), { cache: 'no-store', credentials: 'include' })
          .then(j => {
            if (j.board) board = j.board;
            if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
            if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
            if (j.finished) { finished = true; }
            drawBoard();
            updateTurnText();
          }).catch(e => { console.error('initial game fetch', e); });
        gameTimer = setInterval(() => {
          simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId) + '?_=' + Date.now(), { cache: 'no-store', credentials: 'include' })
            .then(j => {
              if (!j) return;
              if (j.board) board = j.board;
              if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
              if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
              if (j.finished) { finished = true; }
              drawBoard();
              updateTurnText();
              if (j.finished) {
                // 若伺服器回傳 finished，顯示對話框與結果訊息（同上）
                const dlgText = document.getElementById('resultDialogText');
                const text = (j.winner === 'black') ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...');
                dlgText.textContent = text;
                const dlg = document.getElementById('resultDialog');
                dlg.style.display = 'block';
                const confirmBtn = document.getElementById('resultConfirmBtn');
                confirmBtn.onclick = function () { location.href = '/'; };
                setTimeout(() => { if (dlg.style.display !== 'none') location.href = '/'; }, 10000);
              }
            }).catch(e => { console.error('game poll error', e); });
        }, 1000);
      }

      // 投降按鈕事件
      document.getElementById('surrenderBtn').addEventListener('click', function () {
        if (!gameId) return alert('遊戲尚未準備好');
        if (!confirm('確定要投降並返回大廳嗎？')) return;
        simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId) + '/forfeit', { method: 'POST', credentials: 'include' })
          .then(j => { alert('已投降'); location.href = '/'; })
          .catch(e => { console.error('forfeit error', e); alert('投降失敗'); });
      });

      // 初始化
      drawBoard();
      updateTurnText();
      startMatchPoll();

    })();
  </script>
</body>

</html>
