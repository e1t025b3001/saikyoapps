<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <title>五目並べ（Gomoku）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #boardWrap {
      width: 600px;
      margin: 16px auto;
    }

    canvas {
      background: #f5deb3;
      display: block;
      margin: 0 auto;
      border: 1px solid #333;
    }

    #info {
      text-align: center;
      margin-top: 8px;
    }

    #controls {
      text-align: center;
      margin-top: 12px;
    }

    button {
      padding: 8px 12px;
    }

    /* 勝敗確認對話框樣式 */
    #resultDialog {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }

    #resultDialog>div {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      width: 320px;
      margin: 120px auto;
      text-align: center;
    }

    .spectateBanner {
      max-width: 600px;
      margin: 10px auto 0;
      padding: 10px 12px;
      border: 1px solid #ddd;
      background: #fafafa;
      color: #333;
      display: none;
    }
  </style>
</head>

<body th:attr="data-game=${game}">
  <h1 style="text-align:center;">五目並べ</h1>

  <div id="spectateBanner" class="spectateBanner"></div>

  <div id="controls">
    <input type="hidden" id="pageGame" th:value="${game}" />
  </div>

  <div id="surrenderWrap" style="text-align:center;margin-top:8px;">
    <button id="surrenderBtn">投降</button>
  </div>

  <!-- 勝敗確認ダイアログ -->
  <div id="resultDialog"
    style="display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.5);">
    <div style="background:#fff;padding:16px;border-radius:6px;width:320px;margin:120px auto;text-align:center;">
      <div id="resultDialogText" style="margin-bottom:12px;font-weight:bold;color:#b00;"></div>
      <button id="resultConfirmBtn">確認並返回大廳</button>
    </div>
  </div>

  <div id="boardWrap">
    <canvas id="gomokuBoard" width="600" height="600"></canvas>
    <div id="info">
      <div id="turnInfo">等待中...</div>
      <div id="result" style="color:darkred;font-weight:bold;"></div>
    </div>
  </div>

  <script th:inline="javascript">
    /*<![CDATA[*/
    const game = /*[[${game}]]*/ 'gomoku';
    /*]]>*/

    (function () {
      // 簡潔版 Gomoku 前端
      const origin = window.location.origin;
      const size = 15;
      const canvas = document.getElementById('gomokuBoard');
      const ctx = canvas.getContext('2d');
      const cssW = canvas.width,
        cssH = canvas.height;
      const DPR = window.devicePixelRatio || 1;
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.scale(DPR, DPR);
      const cell = cssW / (size - 1);

      let board = Array.from({ length: size }, () => Array(size).fill(0));
      let myColor = null; // 1 black, 2 white
      let currentTurn = 1; // 1 black, 2 white
      let finished = false;
      let gameId = null;
      let matchTimer = null;
      let gameTimer = null;

      let playerBlack = null;
      let playerWhite = null;
      let lastFinishedShown = false;

      function drawBoard() {
        ctx.clearRect(0, 0, cssW, cssH);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i < size; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * cell);
          ctx.lineTo(cssW, i * cell);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(i * cell, 0);
          ctx.lineTo(i * cell, cssH);
          ctx.stroke();
        }
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const v = board[r][c];
            if (v !== 0) drawStone(r, c, v);
          }
        }
      }

      function drawStone(r, c, v) {
        const x = c * cell,
          y = r * cell;
        ctx.beginPath();
        ctx.arc(x, y, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.stroke();
      }

      function posToCell(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const rx = clientX - rect.left,
          ry = clientY - rect.top;
        const c = Math.round(rx / cell),
          r = Math.round(ry / cell);
        return { r, c };
      }

      function updateTurnText() {
        const el = document.getElementById('turnInfo');
        if (finished) return;
        if (!myColor) {
          el.textContent = '観戦中...';
          return;
        }
        el.textContent = currentTurn === myColor ? 'あなたの番' : '相手の番';
      }

      function showResultText(t) {
        document.getElementById('result').textContent = t;
      }

      function simpleFetchJson(url, opts) {
        return fetch(url, opts).then(res => {
          if (!res.ok) throw new Error('HTTP ' + res.status);
          return res.json();
        });
      }

      function getQueryParam(name) {
        const u = new URL(window.location.href);
        return u.searchParams.get(name);
      }

      function updateSpectateBanner() {
        const banner = document.getElementById('spectateBanner');
        if (!banner) return;

        const isSpectator = !myColor;
        if (!isSpectator) {
          banner.style.display = 'none';
          return;
        }

        const pb = playerBlack || '?';
        const pw = playerWhite || '?';
        banner.textContent = `観戦中: ${pb}（黒） vs ${pw}（白） / GAME_ID=${gameId}`;
        banner.style.display = 'block';
      }

      function showFinishedDialogForSpectator(j) {
        if (lastFinishedShown) return;
        lastFinishedShown = true;

        const dlgText = document.getElementById('resultDialogText');
        const winSide = j && j.winner ? (j.winner === 'black' ? '黒' : '白') : '不明';
        dlgText.textContent = `対局終了（勝者: ${winSide}）`;
        const dlg = document.getElementById('resultDialog');
        dlg.style.display = 'block';
        const confirmBtn = document.getElementById('resultConfirmBtn');
        confirmBtn.onclick = function () { location.href = '/gomoku/spectate'; };
      }

      // 點擊處理：只在 server 成功後更新
      canvas.addEventListener('click', function (e) {
        if (finished) return;
        const { r, c } = posToCell(e.clientX, e.clientY);
        if (r < 0 || r >= size || c < 0 || c >= size) return;
        if (board[r][c] !== 0) return;
        if (!gameId) { console.warn('no gameId yet'); return; }
        if (!myColor || currentTurn !== myColor) { console.warn('not your turn'); return; }

        // 禁用點擊
        canvas.style.pointerEvents = 'none';
        simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId) + '/move', {
          method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ x: c, y: r })
        }).then(j => {
          if (j.board) board = j.board;
          if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
          if (j.finished) {
            finished = true;
            if (j.winner) showResultText(j.winner === 'black' ? (myColor === 1 ? 'あなたの勝ち！' : 'あなたの負け...') : (myColor === 2 ? 'あなたの勝ち！' : 'あなたの負け...'));
            // 顯示確認對話框，直到玩家按下確認按鈕才返回大廳；若沒有動作，10 秒後自動返回
            const dlgText = document.getElementById('resultDialogText');
            dlgText.textContent = (j.winner === 'black') ? (myColor === 1 ? 'あなたの勝ち！' : 'あなたの負け...') : (myColor === 2 ? 'あなたの勝ち！' : 'あなたの負け...');
            const dlg = document.getElementById('resultDialog');
            dlg.style.display = 'block';
            const confirmBtn = document.getElementById('resultConfirmBtn');
            confirmBtn.onclick = function () { location.href = '/'; };
            setTimeout(() => { if (dlg.style.display !== 'none') location.href = '/'; }, 10000);
          }
          drawBoard();
          updateTurnText();
        }).catch(err => { console.error('move error', err); }).finally(() => { canvas.style.pointerEvents = ''; });
      });

      function startMatchPoll() {
        matchTimer = setInterval(() => {
          simpleFetchJson(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
            .then(j => {
              if (!j) return;
              if (j.status === 'lobby') {
                clearInterval(matchTimer);
                if (gameTimer) clearInterval(gameTimer);
                location.href = '/';
                return;
              }
              if (j.status === 'playing' && j.gameId) {
                if (!gameId) startGameLoop(j.gameId);
              }
            }).catch(e => { console.error('matching fetch', e); });
        }, 1000);
      }

      function startGameLoop(gid) {
        gameId = gid;

        const surrenderWrap = document.getElementById('surrenderWrap');

        // 立即取得一次遊戲狀態
        simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId), { cache: 'no-store', credentials: 'include' })
          .then(j => {
            if (j.board) board = j.board;
            if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
            if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
            playerBlack = j.playerBlack || null;
            playerWhite = j.playerWhite || null;
            if (j.finished) { finished = true; }

            if (!myColor && surrenderWrap) surrenderWrap.style.display = 'none';

            drawBoard();
            updateTurnText();
            updateSpectateBanner();

            if (j.finished && !myColor) {
              showFinishedDialogForSpectator(j);
            }
          }).catch(e => { console.error('initial game fetch', e); });

        gameTimer = setInterval(() => {
          simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId) + '?_=' + Date.now(), { cache: 'no-store', credentials: 'include' })
            .then(j => {
              if (!j) return;
              if (j.board) board = j.board;
              if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
              if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
              playerBlack = j.playerBlack || playerBlack;
              playerWhite = j.playerWhite || playerWhite;
              if (j.finished) { finished = true; }

              if (!myColor && surrenderWrap) surrenderWrap.style.display = 'none';

              drawBoard();
              updateTurnText();
              updateSpectateBanner();

              if (j.finished) {
                if (!myColor) {
                  showFinishedDialogForSpectator(j);
                  return;
                }

                const dlgText = document.getElementById('resultDialogText');
                const text = (j.winner === 'black') ? (myColor === 1 ? 'あなたの勝ち！' : 'あなたの負け...') : (myColor === 2 ? 'あなたの勝ち！' : 'あなたの負け...');
                dlgText.textContent = text;
                const dlg = document.getElementById('resultDialog');
                dlg.style.display = 'block';
                const confirmBtn = document.getElementById('resultConfirmBtn');
                confirmBtn.onclick = function () { location.href = '/'; };
                setTimeout(() => { if (dlg.style.display !== 'none') location.href = '/'; }, 10000);
              }
            }).catch(e => { console.error('game poll error', e); });
        }, 1000);
      }

      document.getElementById('surrenderBtn').addEventListener('click', function () {
        if (!gameId) return alert('ゲームがまだ開始していません');
        if (!confirm('投降してロビーへ戻りますか？')) return;
        simpleFetchJson(origin + '/gomoku/' + encodeURIComponent(gameId) + '/forfeit', { method: 'POST', credentials: 'include' })
          .then(j => { alert('投降しました'); location.href = '/'; })
          .catch(e => { console.error('forfeit error', e); alert('投降に失敗しました'); });
      });

      // 初期化
      drawBoard();
      updateTurnText();

      // 観戦モード：URL matchId があれば matching/status を使わずに直接 startGameLoop
      const directGid = getQueryParam('matchId');
      if (directGid) {
        startGameLoop(directGid);
      } else {
        startMatchPoll();
      }

    })();
  </script>
</body>

</html>
