<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <title>五目並べ（Gomoku）</title>
  <style>
    body {
      font-family: Arial, sans-serif;
    }

    #boardWrap {
      width: 600px;
      margin: 16px auto;
    }

    canvas {
      background: #f5deb3;
      display: block;
      margin: 0 auto;
      border: 1px solid #333;
    }

    #info {
      text-align: center;
      margin-top: 8px;
    }

    #controls {
      text-align: center;
      margin-top: 12px;
    }

    button {
      padding: 8px 12px;
    }

    /* 勝敗確認對話框樣式 */
    #resultDialog {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }

    #resultDialog>div {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      width: 320px;
      margin: 120px auto;
      text-align: center;
    }
  </style>
</head>

<body th:attr="data-game=${game}">
  <h1 style="text-align:center;">五目並べ</h1>

  <div id="controls">
    <input type="hidden" id="pageGame" th:value="${game}" />
  </div>

  <div style="text-align:center;margin-top:8px;">
    <button id="surrenderBtn">投降</button>
  </div>
  <!-- 勝敗確認ダイアログ -->
  <div id="resultDialog"
    style="display:none;position:fixed;left:0;top:0;width:100%;height:100%;background:rgba(0,0,0,0.5);">
    <div style="background:#fff;padding:16px;border-radius:6px;width:320px;margin:120px auto;text-align:center;">
      <div id="resultDialogText" style="margin-bottom:12px;font-weight:bold;color:#b00;"></div>
      <button id="resultConfirmBtn">確認並返回大廳</button>
    </div>
  </div>

  <div id="boardWrap">
    <canvas id="gomokuBoard" width="600" height="600"></canvas>
    <div id="info">
      <div id="turnInfo">等待中...</div>
      <div id="result" style="color:darkred;font-weight:bold;"></div>
    </div>
  </div>

  <script th:inline="javascript">
    /*<![CDATA[*/
    const game = /*[[${game}]]*/ 'gomoku';
    /*]]>*/

    (function () {
      // 簡潔版 Gomoku 前端，參考 tictactoe.js 的結構
      const origin = window.location.origin;
      const size = 15;
      const canvas = document.getElementById('gomokuBoard');
      const ctx = canvas.getContext('2d');
      const cssW = canvas.width,
        cssH = canvas.height;
      const DPR = window.devicePixelRatio || 1;
      canvas.width = Math.floor(cssW * DPR);
      canvas.height = Math.floor(cssH * DPR);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      ctx.scale(DPR, DPR);
      const cell = cssW / (size - 1);

      let board = Array.from({ length: size }, () => Array(size).fill(0));
      let myColor = null; // 1 black, 2 white
      let currentTurn = 1; // 1 black, 2 white
      let finished = false;
      let gameId = null;
      let matchTimer = null;
      let gameTimer = null;

      function drawBoard() {
        ctx.clearRect(0, 0, cssW, cssH);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i < size; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * cell);
          ctx.lineTo(cssW, i * cell);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(i * cell, 0);
          ctx.lineTo(i * cell, cssH);
          ctx.stroke();
        }
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const v = board[r][c];
            if (v !== 0) drawStone(r, c, v);
          }
        }
      }

      function drawStone(r, c, v) {
        const x = c * cell,
          y = r * cell;
        ctx.beginPath();
        ctx.arc(x, y, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.stroke();
      }

      function posToCell(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        const rx = clientX - rect.left,
          ry = clientY - rect.top;
        const c = Math.round(rx / cell),
          r = Math.round(ry / cell);
        return { r, c };
      }

      function updateTurnText() {
        const el = document.getElementById('turnInfo');
        if (finished) return;
        if (!myColor) {
          el.textContent = '已開始遊戲，等待伺服器分配顏色與回合資訊...';
          return;
        }
        el.textContent = currentTurn === myColor ? '你的回合' : '對手的回合';
      }

      function showResultText(t) {
        document.getElementById('result').textContent = t;
      }

      // 顯示勝敗對話框的共用函式，會停用輪詢並在 10 秒後自動返回大廳
      function showResultDialogText(text) {
        finished = true;
        // 停用輪詢
        if (matchTimer) { clearInterval(matchTimer); matchTimer = null; }
        if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
        const dlgText = document.getElementById('resultDialogText');
        dlgText.textContent = text;
        const dlg = document.getElementById('resultDialog');
        dlg.style.display = 'block';
        const confirmBtn = document.getElementById('resultConfirmBtn');
        confirmBtn.onclick = function () { location.href = '/'; };
        setTimeout(() => { if (dlg.style.display !== 'none') location.href = '/'; }, 10000);
      }

      // 安全的 fetch，回傳 {ok, status, json}
      function fetchSafe(url, opts) {
        return fetch(url, opts).then(res => {
          const status = res.status;
          if (res.headers.get('content-type') && res.headers.get('content-type').includes('application/json')) {
            return res.json().then(j => ({ ok: res.ok, status: status, json: j }));
          }
          return { ok: res.ok, status: status, json: null };
        });
      }

      // fallback: 當伺服器回 404 或出現無法取得遊戲資訊時，嘗試透過 /matching/status 確認玩家狀態，然後顯示結束對話並返回大廳
      function finishFallback() {
        // 停用輪詢
        if (matchTimer) { clearInterval(matchTimer); matchTimer = null; }
        if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
        // 詢問 matching/status 確認是否已回到 lobby
        fetchSafe(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
          .then(r => {
            let text = '對局已結束';
            if (r && r.json) {
              const s = r.json.status;
              if (s === 'lobby') text = '對局已結束，返回大廳';
            }
            showResultDialogText(text);
          }).catch(e => {
            console.warn('finishFallback error', e);
            showResultDialogText('對局已結束');
          });
      }

      // 點擊處理：只在 server 成功後更新
      canvas.addEventListener('click', function (e) {
        if (finished) return;
        const { r, c } = posToCell(e.clientX, e.clientY);
        if (r < 0 || r >= size || c < 0 || c >= size) return;
        if (board[r][c] !== 0) return;
        if (!gameId) { console.warn('no gameId yet'); return; }
        if (!myColor || currentTurn !== myColor) { console.warn('not your turn'); return; }

        // 禁用點擊
        canvas.style.pointerEvents = 'none';
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '/move', {
          method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ x: c, y: r })
        }).then(resp => {
          if (!resp.ok) {
            // 若伺服器回 404 或 400，視為對局已結束或找不到遊戲，使用 fallback
            console.warn('move resp not ok', resp.status);
            finishFallback();
            return;
          }
          const j = resp.json || {};
          if (j.board) board = j.board;
          if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
          if (j.finished) {
            finished = true;
            if (j.winner) {
              const text = (j.winner === 'black') ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...');
              showResultDialogText(text);
            } else {
              showResultDialogText('對局已結束');
            }
          }
          drawBoard();
          updateTurnText();
        }).catch(err => { console.error('move error', err); finishFallback(); }).finally(() => { canvas.style.pointerEvents = ''; });
      });

      // 輪詢 matching/status，拿到 gameId 後啟動 game 輪詢
      function startMatchPoll() {
        matchTimer = setInterval(() => {
          fetchSafe(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
            .then(res => {
              if (!res || !res.ok) return;
              const j = res.json || {};
              if (!j) return;
              if (j.status === 'lobby') {
                clearInterval(matchTimer);
                if (gameTimer) clearInterval(gameTimer);
                location.href = '/';
                return;
              }
              if (j.status === 'playing' && j.gameId) {
                if (!gameId) startGameLoop(j.gameId);
              }
            }).catch(e => { console.error('matching fetch', e); });
        }, 1000);
      }

      function startGameLoop(gid) {
        gameId = gid;
        console.log('start game', gid);
        // 立即取得一次遊戲狀態
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId), { cache: 'no-store', credentials: 'include' })
          .then(resp => {
            if (!resp.ok) { finishFallback(); return; }
            const j = resp.json || {};
            if (j.board) board = j.board;
            if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
            if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
            if (j.finished) {
              const text = (j.winner === 'black') ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...');
              showResultDialogText(text);
            }
            drawBoard();
            updateTurnText();
          }).catch(e => { console.error('initial game fetch', e); finishFallback(); });
        gameTimer = setInterval(() => {
          fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '?_=' + Date.now(), { cache: 'no-store', credentials: 'include' })
            .then(resp => {
              if (!resp.ok) { finishFallback(); return; }
              const j = resp.json || {};
              if (j.board) board = j.board;
              if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
              if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
              if (j.finished) { finished = true; }
              drawBoard();
              updateTurnText();
              if (j.finished) {
                const text = (j.winner === 'black') ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...');
                showResultDialogText(text);
              }
            }).catch(e => { console.error('game poll error', e); finishFallback(); });
        }, 1000);
      }

      // 投降按鈕事件
      document.getElementById('surrenderBtn').addEventListener('click', function () {
        if (!gameId) return alert('遊戲尚未準備好');
        if (!confirm('確定要投降並返回大廳嗎？')) return;
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '/forfeit', { method: 'POST', credentials: 'include' })
          .then(resp => {
            if (!resp.ok) { finishFallback(); return; }
            const j = resp.json || {};
            const winner = j.winner;
            const text = (winner === 'black') ? (myColor === 1 ? '你贏了！' : '你輸了...') : (myColor === 2 ? '你贏了！' : '你輸了...');
            showResultDialogText(text);
          }).catch(e => { console.error('forfeit error', e); finishFallback(); });
      });

      // 初始化
      drawBoard();
      updateTurnText();
      startMatchPoll();

    })();
  </script>
</body>

</html>
