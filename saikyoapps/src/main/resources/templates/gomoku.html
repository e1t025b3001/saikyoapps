<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">

<head>
  <meta charset="UTF-8" />
  <title th:text="#{title.gomoku}">五目並べ（Gomoku）</title>
  <style>
    /* Base page reset */
    html,
    body {
      height: 100%;
      margin: 0;
    }

    body {
      font-family: Arial, sans-serif;
      background: #fff;
    }

    /* scaleRoot: the fixed "paper" that will be scaled to fit viewport */
    #scaleRoot {
      width: 960px;
      /* base paper width */
      height: 800px;
      /* base paper height */
      margin: 0 auto;
      transform-origin: top center;
      box-sizing: border-box;
    }

    /* page container inside the paper */
    #pageContainer {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      box-sizing: border-box;
    }

    /* title, controls and surrender are centered and constrained to board width */
    h1,
    #surrenderWrap,
    #controls,
    #turnWrap {
      width: min(600px, 94vw);
      max-width: 600px;
      margin: 6px auto;
      text-align: center;
      box-sizing: border-box;
    }

    /* responsive centered board container */
    #boardWrap {
      width: min(600px, 94vw);
      max-width: 600px;
      margin: 8px auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1 / 1;
      /* keep square */
      box-sizing: border-box;
    }

    /* canvas fills the square container */
    canvas#gomokuBoard {
      width: 100%;
      height: 100%;
      background: #f5deb3;
      display: block;
      border: 1px solid #333;
      box-sizing: border-box;
    }

    #turnWrap {
      margin-top: 6px;
    }

    /* result dialog */
    #resultDialog {
      display: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
    }

    #resultDialog>div {
      background: #fff;
      padding: 16px;
      border-radius: 6px;
      width: 320px;
      margin: 120px auto;
      text-align: center;
    }

    .spectateBanner {
      max-width: 600px;
      margin: 10px auto 0;
      padding: 10px 12px;
      border: 1px solid #ddd;
      background: #fafafa;
      color: #333;
      display: none;
    }
  </style>
</head>

<body th:attr="data-game=${game}">
  <!-- I18N: server-rendered messages made available to client JS -->
  <script th:inline="javascript">
    /*<![CDATA[*/
    const I18N = {
      game: /*[[${game}]]*/ 'gomoku',
      spectateLabel: /*[[#{spectate.spectating}]]*/ 'Spectating...',
      turnYour: /*[[#{turn.your}]]*/ 'Your turn',
      turnOpponent: /*[[#{turn.opponent}]]*/ 'Opponent\'s turn',
      spectateBannerLabel: /*[[#{spectate.label}]]*/ 'Spectating:',
      spectateBlack: /*[[#{spectate.black}]]*/ '(Black)',
      spectateWhite: /*[[#{spectate.white}]]*/ '(White)',
      spectateGameIdLabel: /*[[#{spectate.gameIdLabel}]]*/ ' / GAME_ID=',
      gameNotStarted: /*[[#{alert.gameNotStarted}]]*/ 'Game not started yet',
      confirmForfeit: /*[[#{confirm.surrender}]]*/ 'Are you sure to forfeit and return to lobby?',
      resultWinYou: /*[[#{result.win.you}]]*/ 'You win!',
      resultLoseYou: /*[[#{result.lose.you}]]*/ 'You lose...',
      resultFinished: /*[[#{result.finished}]]*/ 'The game has finished',
      resultFinishedLobby: /*[[#{result.finished.lobby}]]*/ 'The game has finished (returning to lobby)',
      resultReturnBtn: /*[[#{button.confirm_and_return}]]*/ 'Confirm and return',
      buttonSurrender: /*[[#{button.surrender}]]*/ 'Surrender',
      waiting: /*[[#{game.waiting}]]*/ 'Waiting...'
    };
    /*]]>*/
  </script>

  <div id="scaleRoot">
    <div id="pageContainer">
      <h1 style="text-align:center;" th:text="#{title.gomoku}">五目並べ</h1>

      <div id="spectateBanner" class="spectateBanner"></div>

      <div id="controls">
        <input type="hidden" id="pageGame" th:value="${game}" />
      </div>

      <div id="surrenderWrap" style="text-align:center;margin-top:8px;">
        <button id="surrenderBtn" th:text="#{button.surrender}">投降</button>
      </div>

      <div id="turnWrap">
        <div id="turnInfo" th:text="#{game.waiting}">等待中...</div>
        <div id="result" style="color:darkred;font-weight:bold;"></div>
      </div>

      <div id="boardWrap">
        <canvas id="gomokuBoard" width="600" height="600"></canvas>
      </div>

      <div id="resultDialog" style="display:none;">
        <div>
          <div id="resultDialogText" style="margin-bottom:12px;font-weight:bold;color:#b00;"></div>
          <button id="resultConfirmBtn" th:text="#{button.confirm_and_return}">確認並返回大廳</button>
        </div>
      </div>

    </div>
  </div>

  <script th:inline="javascript">
    /*<![CDATA[*/
    const game = /*[[${game}]]*/ 'gomoku';
    /*]]>*/

    (function () {
      const origin = window.location.origin;
      const size = 15;
      const canvas = document.getElementById('gomokuBoard');
      const ctx = canvas.getContext('2d');

      // track global scale applied to #scaleRoot
      let currentGlobalScale = 1.0;

      // compute and apply global page scale so the 'paper' fits viewport
      function applyGlobalScale() {
        const root = document.getElementById('scaleRoot');
        if (!root) return;
        const baseW = 960,
          baseH = 800;
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const scale = Math.max(0.35, Math.min(1.0, Math.min(vw / baseW, vh / baseH)));
        currentGlobalScale = scale;
        root.style.transform = 'scale(' + scale + ')';
        document.body.style.minHeight = Math.ceil(baseH * scale) + 'px';
      }

      // resize canvas internal buffer according to displayed CSS size / currentGlobalScale
      let cssW = 600,
        cssH = 600;
      let cell = 0;
      function resizeCanvasAndLayout() {
        const rect = canvas.getBoundingClientRect();
        // rect is affected by page scale; divide by currentGlobalScale to get unscaled CSS pixels
        cssW = Math.max(1, rect.width / Math.max(0.0001, currentGlobalScale));
        cssH = Math.max(1, rect.height / Math.max(0.0001, currentGlobalScale));

        // recalc DPR in case browser zoom or display scale changed
        const DPR = window.devicePixelRatio || 1;

        // set internal buffer for HiDPI
        canvas.width = Math.floor(cssW * DPR);
        canvas.height = Math.floor(cssH * DPR);
        canvas.style.width = cssW + 'px';
        canvas.style.height = cssH + 'px';

        // set transform so drawing uses CSS pixels scaled by DPR
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

        cell = cssW / (size - 1);
      }

      // drawing helpers
      let board = Array.from({ length: size }, () => Array(size).fill(0));
      let myColor = null; // 1 black, 2 white
      let currentTurn = 1;
      let finished = false;
      let gameId = null;
      let matchTimer = null;
      let gameTimer = null;
      let playerBlack = null,
        playerWhite = null;
      let lastFinishedShown = false;

      function drawBoard() {
        ctx.clearRect(0, 0, cssW, cssH);
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 1;
        for (let i = 0; i < size; i++) {
          ctx.beginPath();
          ctx.moveTo(0, i * cell);
          ctx.lineTo(cssW, i * cell);
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(i * cell, 0);
          ctx.lineTo(i * cell, cssH);
          ctx.stroke();
        }
        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const v = board[r][c];
            if (v !== 0) drawStone(r, c, v);
          }
        }
      }

      function drawStone(r, c, v) {
        const x = c * cell,
          y = r * cell;
        ctx.beginPath();
        ctx.arc(x, y, cell * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = v === 1 ? 'black' : 'white';
        ctx.fill();
        ctx.strokeStyle = '#222';
        ctx.stroke();
      }

      function posToCell(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        // convert client coords to canvas CSS pixels, accounting for global scale
        const rx = (clientX - rect.left) / Math.max(0.0001, currentGlobalScale);
        const ry = (clientY - rect.top) / Math.max(0.0001, currentGlobalScale);
        const c = Math.round(rx / cell),
          r = Math.round(ry / cell);
        return { r, c };
      }

      function updateTurnText() {
        const el = document.getElementById('turnInfo');
        if (finished) return;
        if (!myColor) {
          el.textContent = I18N.spectateLabel || 'Spectating...';
          return;
        }
        el.textContent = currentTurn === myColor ? (I18N.turnYour || 'Your turn') : (I18N.turnOpponent || 'Opponent\'s turn');
      }

      function showResultDialogText(text, backToSpectate) {
        finished = true;
        if (matchTimer) { clearInterval(matchTimer); matchTimer = null; }
        if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
        const dlgText = document.getElementById('resultDialogText');
        dlgText.textContent = text;
        const dlg = document.getElementById('resultDialog');
        dlg.style.display = 'block';
        const confirmBtn = document.getElementById('resultConfirmBtn');
        confirmBtn.onclick = function () { location.href = backToSpectate ? '/gomoku/spectate' : '/'; };
        setTimeout(() => { if (dlg.style.display !== 'none') location.href = backToSpectate ? '/gomoku/spectate' : '/'; }, 10000);
      }

      function fetchSafe(url, opts) {
        return fetch(url, opts).then(res => {
          const status = res.status;
          const contentType = res.headers.get('content-type') || '';
          if (contentType.includes('application/json')) return res.json().then(j => ({ ok: res.ok, status, json: j }));
          return { ok: res.ok, status, json: null };
        });
      }

      function getQueryParam(name) {
        const u = new URL(window.location.href);
        return u.searchParams.get(name);
      }

      function updateSpectateBanner() {
        const banner = document.getElementById('spectateBanner');
        if (!banner) return;

        const isSpectator = !myColor;
        if (!isSpectator) {
          banner.style.display = 'none';
          return;
        }

        const pb = playerBlack || '?';
        const pw = playerWhite || '?';
        banner.textContent = (I18N.spectateBannerLabel || 'Spectating:') + ` ${pb}${I18N.spectateBlack || '(Black)'} vs ${pw}${I18N.spectateWhite || '(White)'}${I18N.spectateGameIdLabel || ' / GAME_ID='}${gameId}`;
        banner.style.display = 'block';
      }

      function showFinishedDialogForSpectator(j) {
        if (lastFinishedShown) return;
        lastFinishedShown = true;

        const winSide = j && j.winner ? (j.winner === 'black' ? '黒' : '白') : '不明';
        showResultDialogText(`対局終了（勝者: ${winSide}）`, true);
      }

      function finishFallback() {
        if (matchTimer) { clearInterval(matchTimer); matchTimer = null; }
        if (gameTimer) { clearInterval(gameTimer); gameTimer = null; }
        fetchSafe(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
          .then(r => {
            let text = I18N.resultFinished || '対局が終了しました';
            if (r && r.json) {
              const s = r.json.status;
              if (s === 'lobby') text = I18N.resultFinishedLobby || '対局が終了しました（ロビーへ戻ります）';
            }
            showResultDialogText(text, false);
          }).catch(e => {
            console.warn('finishFallback error', e);
            showResultDialogText(I18N.resultFinished || '対局が終了しました', false);
          });
      }

      // click handling
      canvas.addEventListener('click', function (e) {
        if (finished) return;
        const { r, c } = posToCell(e.clientX, e.clientY);
        if (r < 0 || r >= size || c < 0 || c >= size) return;
        if (board[r][c] !== 0) return;
        if (!gameId) { console.warn('no gameId yet'); return; }
        if (!myColor || currentTurn !== myColor) { console.warn('not your turn'); return; }

        canvas.style.pointerEvents = 'none';
        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '/move', {
          method: 'POST', credentials: 'include', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ x: c, y: r })
        }).then(resp => {
          if (!resp.ok) { finishFallback(); return; }
          const j = resp.json || {};
          if (j.board) board = j.board;
          if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
          if (j.finished) {
            finished = true;
            if (!myColor) {
              showFinishedDialogForSpectator(j);
            } else if (j.winner) {
              const text = (j.winner === 'black')
                ? (myColor === 1 ? I18N.resultWinYou : I18N.resultLoseYou)
                : (myColor === 2 ? I18N.resultWinYou : I18N.resultLoseYou);
              showResultDialogText(text, false);
            } else {
              showResultDialogText(I18N.resultFinished, false);
            }
          }
          drawBoard(); updateTurnText();
          // 効果音再生: 自分の手を置いたときにプレース音を鳴らす
          try { if (window.soundManager) window.soundManager.play('place'); } catch (e) { console.warn('sound play error', e); }
        }).catch(err => { console.error('move error', err); finishFallback(); }).finally(() => { canvas.style.pointerEvents = ''; });
      });

      // polling and game loop (kept as original logic)
      function startMatchPoll() {
        matchTimer = setInterval(() => {
          fetchSafe(origin + '/matching/status?game=' + encodeURIComponent(game), { cache: 'no-store', credentials: 'include' })
            .then(res => {
              if (!res || !res.ok) return;
              const j = res.json || {};
              if (!j) return;
              if (j.status === 'lobby') { clearInterval(matchTimer); if (gameTimer) clearInterval(gameTimer); location.href = '/'; return; }
              if (j.status === 'playing' && j.gameId) { if (!gameId) startGameLoop(j.gameId); }
            }).catch(e => { console.error('matching fetch', e); });
        }, 1000);
      }

      function startGameLoop(gid) {
        gameId = gid;
        const surrenderWrap = document.getElementById('surrenderWrap');

        fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId), { cache: 'no-store', credentials: 'include' })
          .then(resp => {
            if (!resp.ok) { finishFallback(); return; }
            const j = resp.json || {};
            if (j.board) board = j.board;
            if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
            if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
            playerBlack = j.playerBlack || null;
            playerWhite = j.playerWhite || null;
            if (j.finished) finished = true;
            if (!myColor && surrenderWrap) surrenderWrap.style.display = 'none';
            resizeCanvasAndLayout(); drawBoard(); updateTurnText(); updateSpectateBanner();
            if (j.finished && !myColor) showFinishedDialogForSpectator(j);
            if (j.finished && myColor) {
              const text = (j.winner === 'black')
                ? (myColor === 1 ? I18N.resultWinYou : I18N.resultLoseYou)
                : (myColor === 2 ? I18N.resultWinYou : I18N.resultLoseYou);
              showResultDialogText(text, false);
            }
          }).catch(e => { console.error('initial game fetch', e); finishFallback(); });

        gameTimer = setInterval(() => {
          fetchSafe(origin + '/gomoku/' + encodeURIComponent(gameId) + '?_=' + Date.now(), { cache: 'no-store', credentials: 'include' })
            .then(resp => {
              if (!resp.ok) { finishFallback(); return; }
              const j = resp.json || {};
              if (j.board) board = j.board;
              if (j.turn) currentTurn = (j.turn === 'black') ? 1 : 2;
              if (j.myColor) myColor = (j.myColor === 'black') ? 1 : 2;
              playerBlack = j.playerBlack || playerBlack;
              playerWhite = j.playerWhite || playerWhite;
              if (j.finished) finished = true;
              if (!myColor && surrenderWrap) surrenderWrap.style.display = 'none';
              drawBoard(); updateTurnText(); updateSpectateBanner();
              if (j.finished) {
                if (!myColor) {
                  showFinishedDialogForSpectator(j);
                } else {
                  const text = (j.winner === 'black')
                    ? (myColor === 1 ? I18N.resultWinYou : I18N.resultLoseYou)
                    : (myColor === 2 ? I18N.resultWinYou : I18N.resultLoseYou);
                  showResultDialogText(text, false);
                }
              }
            }).catch(e => { console.error('game poll error', e); finishFallback(); });
        }, 1000);
      }

      // handle viewport/zoom changes: keep scale and canvas in sync
      function onViewportChange() {
        try {
          applyGlobalScale();
          resizeCanvasAndLayout();
          drawBoard();
          updateTurnText();
          updateSpectateBanner();
        } catch (e) {
          console.warn('onViewportChange error', e);
        }
      }

      window.addEventListener('resize', onViewportChange);
      window.addEventListener('orientationchange', onViewportChange);
      window.addEventListener('pageshow', onViewportChange);
      window.addEventListener('focus', onViewportChange);
      if (window.visualViewport && window.visualViewport.addEventListener) {
        window.visualViewport.addEventListener('resize', onViewportChange);
        window.visualViewport.addEventListener('scroll', onViewportChange);
      }

      // initial setup
      applyGlobalScale();
      resizeCanvasAndLayout();
      drawBoard();
      startMatchPoll();


    // sound fragment を挿入: script で soundManager を読み込み
      (function insertSoundScripts() {
        // soundManager.js を読み込む
        const sm = document.createElement('script');
        sm.src = '/js/soundManager.js';
        sm.defer = true;
        document.body.appendChild(sm);

        // sound controls fragment を読み込む via fetch
        const insertFragment = function () {
          fetch('/fragments/sound_controls.html').then(r => r.text()).then(html => {
            const div = document.createElement('div');
            div.innerHTML = html;
            document.body.appendChild(div);
          }).catch(e => {
            // fallback: try to load from templates path
            console.warn('failed to insert sound controls fragment', e);
          });
        };

        // DOMContentLoaded 後に挿入
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', insertFragment);
        else insertFragment();
      })();
    }) ();
  </script>

</body>

</html>
