調查目標

- 調查「五目並べ（Gomoku / 5木並べ）」的遊戲規則與常見實作方式
- 評估在現有專案架構下，為每個遊戲新增「遊戲實際情況資料表」與對戰履歷表（match history）所需的資料結構與 API
- 比較即時同步技術（輪詢 / SSE / WebSocket），並提出對本專案的建議方案

日期

- 2025-12-07

摘要（結論）

- 五目並べ是一種在 NxN 棋盤上雙方輪流下子，先連成五子（直、橫、斜）即勝的簡單棋類遊戲。常見棋盤大小為 15x15 或 19x19。實作重點在於：棋盤表示、合法著子檢查、連五判定、先手優勢處理（可忽略 Renju 限制，採簡單規則）。
- 因為遊戲需要雙向即時同步（A 下子後 B 立即看到），最佳做法是使用 WebSocket（Spring 的 STOMP 或原生 WebSocket）來推送移動事件；若只想單向推播也可用 SSE，但 SSE 不適合要求玩家發送大量即時操作的雙向通訊情境。
- 資料庫設計建議：對每個遊戲（包括五目並べ）建立遊戲狀態表（game session）與 moves 表；另外一個共用的 match_history 表記錄全部對戰結果。遊戲結束時把結果寫入 match_history，並刪除或標記遊戲狀態表為已結束。

1) 五目並べ（Gomoku）規則摘要

- 棋盤：一般採 15x15 或 19x19。
- 玩家：兩人，黑（先手）與白（後手）。
- 棋子：輪流在空點上落子，一旦某一方在任一方向（橫、直、左斜、右斜）連成 5 顆連續棋子即勝。超過五子（6 子以上）在基本 Gomoku 中也視為勝利（Renju 有細則，但可不實作）。
- 先手優勢：先手有優勢，若需平衡可加入禁手或先手讓步，但初期可採簡單規則（先連五者勝）。

參考實作要點（網路上常見做法）

- 棋盤資料結構通常以二維陣列（int[15][15]）或一維陣列（size*N + x）表示；也可用 JSON 儲存當前棋盤狀態。
- 落子時先驗證該格是否為空，然後將該步記錄到 moves table，更新 game session 的 turn 與 board_state（或僅保存 moves，必要時由 moves 重建 board）。
- 勝負判定以檢查落子點在 4 個方向上連續相同棋子數量是否 >= 4（包含自身即 5）。
- UI 常用 HTML table / flex box / canvas 來繪製棋盤，點擊空格後發送 move 事件到伺服器。
- 即時同步：常用 WebSocket（Socket.IO、STOMP over WebSocket）或短輪詢／SSE。兩人遊戲建議 WebSocket。

2) 技術比較：Polling / SSE / WebSocket

- Polling (HTTP GET 每 N 秒)
  - 優點：簡單，無需伺服器維持長連線
  - 缺點：延遲依賴輪詢間隔，效率差，伺服器請求多
- SSE (Server-Sent Events)
  - 優點：伺服器向客戶端單向推送，實作較 WebSocket 簡單
  - 缺點：單向（客戶端向伺服器仍需 HTTP POST/PUT），連線管理需注意，對雙向頻繁互動不如 WebSocket
- WebSocket
  - 優點：雙向即時通訊，延遲低，適合互動遊戲
  - 缺點：實作與伺服器資源管理複雜度較高，需處理斷線與重連

建議：對於五目並べ這類雙人即時遊戲，採用 WebSocket 為首選；若短期內不想大改架構，可先以現有的 /matching/status 輪詢作為過渡，但會有即時性與頻寬問題。

3) 所需新增資料表（建議）

- 共用對戰歷史表（match_history）
  - id BIGINT AUTO_INCREMENT
  - game_name VARCHAR(64) -- 'gomoku', 'othello', ...
  - player1 VARCHAR(255)
  - player2 VARCHAR(255)
  - winner VARCHAR(255) NULLABLE
  - started_at TIMESTAMP
  - ended_at TIMESTAMP NULLABLE
  - extra JSON / TEXT -- 可記錄摘要、移動數量或其他元資料

- 五目並べ遊戲會話表（gomoku_game）
  - id BIGINT AUTO_INCREMENT
  - game_id VARCHAR(64) UNIQUE -- 與 application 層一致的會話 id（可用 UUID）
  - player_black VARCHAR(255)
  - player_white VARCHAR(255)
  - board_state TEXT / JSON NULLABLE -- 可儲存整個棋盤（例如 JSON 2D 陣列）或空
  - turn VARCHAR(255) -- 目前輪到誰（player_black/player_white）或 'black'/'white'
  - status VARCHAR(32) -- 'playing' / 'finished'
  - created_at TIMESTAMP
  - updated_at TIMESTAMP

- 五目並べ落子記錄表（gomoku_move）
  - id BIGINT AUTO_INCREMENT
  - game_id VARCHAR(64) -- FK -> gomoku_game.game_id
  - player VARCHAR(255)
  - x INT
  - y INT
  - move_no INT
  - created_at TIMESTAMP
  - extra JSON / TEXT

- 若要為其他遊戲也建立專屬表，模式類似：{game}_game 與 {game}_move（或 action）

注：若不想建立每個遊戲獨立表，也可以建立通用的 game_session 與 game_event（帶 game_name 欄位）；但題主要求「每一個遊戲的名稱都加上相對應的遊戲實際情況資料庫」，建議為清楚性與彈性建立每遊戲專屬表。

4) Controller / API / WebSocket 設計（建議）

- REST API
  - POST /gomoku/{gameId}/move  -- 發送一手（若使用 WebSocket，改為 WS message）
  - GET /gomoku/{gameId} -- 取得 game session（包括 board_state）
  - POST /gomoku/{gameId}/forfeit -- 棄權
  - POST /gomoku/{gameId}/end -- 結束比賽（伺服器或管理者呼叫）

- WebSocket 通道（若採 WebSocket）
  - Endpoint: /ws/gomoku
  - 訊息類型：JOIN(gameId, user), MOVE(gameId, user, x, y, moveNo), FORFEIT(gameId, user), SYNC(gameId, boardState)
  - 伺服器收到 MOVE 後：驗證合法性 -> 儲存 move -> 更新 gomoku_game（turn, board_state）-> 廣播 MOVE 給同場所有 client -> 若判勝則廣播 END

- 前端行為
  - 連線 WebSocket 並 JOIN gameId
  - 畫面繪製棋盤（建議 15x15），點擊空格發送 MOVE
  - 收到對手的 MOVE 後在畫面上繪製棋子
  - 若收到 END 或 players_status 變回 lobby，顯示勝負並 5 秒後導回首頁

5) 需要修改或新增的專案檔案（初步）

- models：新增 GomokuGame, GomokuMove, MatchHistory, PlayerStatus（已存在）
- mapper（MyBatis）：新增 GomokuGameMapper, GomokuMoveMapper, MatchHistoryMapper
- controller：新增 GomokuController（處理 REST 與 WebSocket 連結或委派）
- templates：新增 gomoku.html（實際遊戲畫面）
- static/js：新增 gomoku.js（前端 WebSocket / UI 邏輯）
- resources/schema.sql：新增上述資料表建表語句

6) 需要的後端邏輯細項

- 建會話（game session）時產生唯一 gameId，並把兩位玩家填入 gomoku_game（player_black, player_white）。隨機決定先手（黑）。
- 當 players_status 變為 playing（配對成功流程），建立 gomoku_game 紀錄（或在配對流程中直接建立）。
- Move 流程：驗證是否為該玩家的回合、格子是否為空、是否已經結束。若合法：
  - 寫入 gomoku_move
  - 更新 gomoku_game.turn 與 board_state（或不儲存 board_state 而以 move 列表重建）
  - 檢查勝利（連五）
  - 廣播 move 給對方
- 結束流程：當偵測到勝負或 forfeit：
  - 更新 gomoku_game.status = 'finished'
  - 將結果寫入 match_history
  - 更新兩位 players_status 為 lobby
  - 刪除或保留 gomoku_game / gomoku_move 資料（題主要求：分出勝負時刪除遊戲的實際情況資料表，我建議改成標記 finished 並保留歷史。若一定要刪除，可在寫入 match_history 後刪除 gomoku_game 與 gomoku_move。)

7) 前端 UI 建議（五目並べ）

- 棋盤大小：建議 15x15（視行動裝置或桌面版調整）
- 顯示要素：棋盤、當前回合提示、玩家名稱、放棄按鈕、倒數或提示文字
- 互動：點擊空格發送 MOVE（WebSocket），disable 非該玩家回合
- 同步：收到 MOVE 即時在畫面上渲染
- 結束：顯示誰勝利的訊息，5 秒後自動回到首頁

8) 風險與注意事項

- race condition：同一格的雙重提交需由後端驗證與交易鎖保護
- 斷線與重連：若玩家斷線需處理是否自動判負或等待重連
- 權限驗證：WebSocket 連線需驗證使用者（session / token）以防作弊
- DB 成長：若保留所有 moves，資料會變大，應考慮歸檔策略

9) 建議的下一步（計畫階段要做的清單）

A. 設計資料表並在 schema.sql 加入（gomoku_game, gomoku_move, match_history）
B. 實作 MyBatis mapper 與 model 類別
C. 實作配對成功後建立 game session 的邏輯（MatchingController 擴充）
D. 實作 WebSocket（Controller 或配置）與前端 gomoku.js
E. 實作 gomoku.html 前端視覺與交互
F. 撰寫測試/手動驗證步驟並記錄在 docs/reports/done 中（DoD）

DoD（驗收標準）

- 當兩位玩家配對成功且 players_status = playing 時，自動建立一個 gomoku_game 並將兩位玩家加入，任意一方下子可在另一方畫面即時顯示（低延遲）。
- 任一方下子後，資料表 gomoku_move 有新增記錄，gomoku_game.turn 更新正確，且勝負檢查正確觸發。
- 當判出勝負或玩家按放棄（forfeit）時，兩位 players_status 更新為 lobby，match_history 有新增一筆紀錄，並依專案規則刪除或標記該遊戲 session 為已結束。
- 前端顯示勝負訊息並在 5 秒後自動回到遊戲選單。

參考連結（建議閱讀）

- Gomoku 規則與實作說明（維基 / 各種介紹文章）
- WebSocket 與 Spring 實作範例（STOMP over WebSocket）
- 五目並べ JavaScript 實作範例（Github）


---

以上為調查結果摘要。如需我把此調查結果轉為「計畫（docs/personal_tasks/tasks_YYYY_MM_DD_描述.md）」或直接進入實作（從建表開始），請回覆「計畫」或「實作」。
