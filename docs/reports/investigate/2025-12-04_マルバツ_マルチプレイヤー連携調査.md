# 2025-12-04 マルバツ（TicTacToe）マルチプレイヤー連携調査

## 要約
既存の「一人用マルバツ（/tictactoe）」と既存のマッチング機能を連携し、ログイン済みの2端末で対戦可能にするための調査報告書。
本調査では現在のワークスペース構成、関連しそうなファイル群、実装方針（短期MVPと推奨実装）、必要なエンドポイント・データモデル、想定される問題点と検証手順（DoD）をまとめる。

## 現状把握（確認すべき箇所）
以下のファイル・ディレクトリを優先して調査してください（ワークスペースルートからの相対パス）:

- テンプレート（フロント）
  - `src/main/resources/templates/tictactoe.html`  ← 既存の一人用画面
  - `src/main/resources/templates/marubatsu.html` ← マッチング画面遷移先（今回連携対象）
  - `src/main/resources/templates/matching.html`  ← マッチング開始/待機画面
- 静的JS
  - `src/main/resources/static/js/tictactoe.js`  ← 一人用ゲームロジック（再利用可能箇所を確認）
- サーバ側（コントローラ／サービス）
  - `src/main/java/team1/saikyoapps/controller/` 以下のマッチング関連コントローラ（例: MatchingController, MatchController等）
  - `src/main/java/team1/saikyoapps/config/SecurityConfig.java`（ログイン処理やCSRFの扱い確認）
- データモデル／永続化
  - `src/main/resources/schema.sql`（マッチ情報やゲーム状態のDBスキーマ）
  - `src/main/java/team1/saikyoapps/model/` 以下に Match や GameState クラスがあるか確認

（注）現在のワークスペースにはテンプレートや静的ファイルが存在することは確認済みです。詳細な実装内容は上記ソースファイルを実際に開いて確認してください。

## 要件（ユーザ要望の整理）
- 2人で同じマッチに参加し、交互に手を選びプレイできること
- マッチング開始 → 待機状態 → 相手が揃ったら自動的にゲーム画面へ遷移すること
- 各プレイヤーの操作が相手に反映されること（リアルタイム性は最低限保証）
- 終了（勝敗・引き分け）判定が両端末で一致して表示されること
- 投了（戻る）ボタンでマッチを解消できること

## 実装方針（短期MVP と 推奨実装）
短期MVP（早く動くこと重視）
- サーバ側に試合（match）IDと盤面状態を保持するAPIを追加
  - GET `/match/state?matchId=xxx` → JSONで盤面・ターン・状態を返す
  - POST `/match/move` → {matchId, playerId, pos} を受け取りサーバ側で盤面更新・勝敗判定
- フロントは既存の `tictactoe.js` ロジックを再利用し、ポーリング（1〜2秒）で `/match/state` を取得して画面を更新
- マッチングが揃ったら既存のマッチング処理から `marubatsu.html?matchId=xxx` にリダイレクト（またはテンプレートにmatchIdを埋め込む）
利点: 実装が単純で既存構成に干渉しにくい。実装期間が短い。
欠点: リアルタイム性・負荷の点で劣る。

推奨実装（中長期）
- WebSocket（Spring WebSocket / STOMP）または Server-Sent Events を導入し、盤面更新・ターン通知をプッシュ送信
- サーバ側に MatchService を用意してゲームルール（勝敗判定・ターン管理）を一元化
- DB にマッチ履歴を残す（再接続対策・観戦用）
利点: 低遅延で快適な対戦。再接続や観戦など拡張が容易。
欠点: 実装量が増える。設定・セキュリティ確認が必要。

## 具体的に必要な変更点（MVPベース）
- サーバ
  - `MatchController`（既存がなければ新規作成）
    - GET `/matching/status` は既にある可能性があるため、マッチ状態を返すエンドポイントを拡張
    - GET `/match/state`：matchIdで盤面とターン・勝敗を返す
    - POST `/match/move`：moveを受け取りバリデーション（自分のターンか、空きマスかなど）→更新→DB保存
  - `Match` モデル（matchId, player1Id, player2Id, board(9セル), turn, status）
  - `MatchService`：勝敗判定ロジックをサーバ側に実装
- フロント
  - `src/main/resources/templates/marubatsu.html` に `matchId` を含める（既に `data-game` や `game` を埋めているため、matchId追加）
  - 新規 `src/main/resources/static/js/marubatsu.js` を作成してポーリング実装・クリックで POST `/match/move`
  - 既存 `tictactoe.js` のゲーム盤ロジックを流用可能なら分割して再利用

## セキュリティ/運用面の注意
- CSRF トークン: POST を行う際は既存の Thymeleaf の CSRF 埋め込みを利用する（`_csrf.parameterName` / `_csrf.token`）
- 認証: matchId に紐づく playerId とログインユーザが一致するかサーバ側で必ずチェック
- 不正リクエスト: 自分のターンでないのにmoveできないようにサーバ側で検査
- 切断/再接続: 短期は「待機時間経過で敗北/引分」を採るか、長期はWebSocket再接続を実装

## 想定される問題点
- 既存のマッチング実装がどう盤面遷移先（どのURLへ遷移）を実現しているか不明。matching→marubatsuへmatchIdを渡す処理を追加する必要がある。
- 既存の一人用 `tictactoe.js` が UI とロジックを混在していると再利用が難しい。リファクタが必要。
- WebSocket を導入するとフロント／サーバ設定（STOMPエンドポイントやメッセージブローカー）が必要。

## テスト/受入基準（DoD）
以下の手順で確認できれば完了とする：
1. ブラウザAで userA でログイン→マルバツ選択→マッチング開始
2. ブラウザBで userB でログイン→マルバツ選択→マッチング開始
3. 両ブラウザが `marubatsu` のゲーム画面（例: `/marubatsu?matchId=xxx`）に遷移すること
4. プレイヤーAがマスを選ぶと即座にプレイヤーBの画面に反映され、ターンが切り替わること（ポーリングの場合、遅延は最大ポーリング間隔）
5. 勝敗判定が両端末で一致して表示されること
6. 投了ボタンでマッチが終了し、待機画面または結果画面に遷移すること
7. 不正操作（相手のターンの移動など）はサーバで拒否されること

## 作業順序（提案）
1. 影響範囲の調査（上記ファイルの参照）→該当コントローラ名・既存APIを特定
2. Matchモデル／MatchService の設計（最小のデータ構造）
3. API（GET /match/state, POST /match/move）を実装（サーバ検証付き）
4. `marubatsu.html` に matchId を渡す仕組みを追加（マッチング完了時）
5. フロント実装（ポーリングベース）→動作確認
6. 必要であれば WebSocket への移行

## 参考（調査時に見るべき箇所）
- `src/main/resources/templates/matching.html`（どのURLへリダイレクトしているか確認）
- `src/main/resources/static/js/tictactoe.js`（既存ロジックの再利用可能箇所）
- `src/main/resources/schema.sql`（DBにmatchテーブルがあるか）

## 次に取るべきアクション（ユーザへの質問）
1. 優先実装は短期MVP（ポーリング）で良いですか、それとも最初からWebSocketを採用しますか？
2. 私に実装（コード変更）を進めて良いですか（進める場合は「計画」フェーズ→新しいタスクファイルを作成します）？

---
調査は以上です。次は「計画」フェーズに進める準備ができています。実装方針（ポーリング優先かWebSocket導入か）を教えてください。
