# 2025-12-22 Darour マッチング実装調査

## 概要
本調査は、既存プロジェクトで採用されているマッチング実装パターン（/matching/status を中心としたポーリング／オンデマンド game レコード生成）を参照し、カードゲーム「Darour（大老二）」に対して同様のマッチング機能をどのように最小限かつ分かりやすく実装するかを検討した結果をまとめたものです。

## 参照した既存箇所
- マッチングフロー（ポーリング）: `src/main/resources/templates/matching.html`（`/matching/status` をポーリング）
- 既存の MatchingController: `src/main/java/team1/saikyoapps/controller/MatchingController.java`
- 既存ゲームのコントローラ実装例: `GomokuController`, `MarubatsuController`（`src/main/java/team1/saikyoapps/controller/`）
- in-memory マッチ管理サービス: `src/main/java/team1/saikyoapps/service/MatchService.java`
- DB スキーマ（ゲームごとのテーブル設計例）: `src/main/resources/schema.sql`
- Darour ドメインモデル（Card/Hand/Rank/Suit）およびビュー: `src/main/java/team1/saikyoapps/darour/model/*`, `src/main/java/team1/saikyoapps/darour/controller/DarourController.java`, `src/main/resources/templates/dairo.html`
- クライアント側の既存ポーリング実装例: `src/main/resources/static/js/marubatsu.js`, `templates/gomoku.html` 内スクリプト

## 既存パターン（要点）
1. フロントは `/matching/status?game={game}` を定期ポーリングし、`status` や `gameId` を受け取る。
2. MatchingController が待機キュー（`matching_queue` テーブル）や `players_status` を参照して状態を返す。
3. 必要に応じてサーバ側で on‑demand にゲーム用のレコード（例: `gomoku_game`）を作成し、`gameId` を返す。フロントは `/{game}?matchId={gameId}` へ遷移してポーリングを続ける。
4. 各ゲームは GET（状態取得）・POST（move/forfeit 等）の API を実装し、サーバ側で妥当性検査と勝敗処理を行う。
5. 短期はポーリングで実装し、後で WebSocket 等へ拡張する方針が採られている。

## Darour への適用案（最小実装 / MVP）
目的: 既存フローを最大限流用し、最小の変更で配対（マッチング）→ 対局開始 を実現する。

1. MatchingController に `darour` の扱いを追加
   - `matching_queue` から待機者を取り出し、必要人数（Darour は 3 人）になったらマッチ成立とする。
   - 成立時に `MatchService#createMatch` あるいは darour_game 用の簡易レコードを作成し `gameId` を返す。

2. Darour のゲーム API（最小）
   - GET `/darour/{gameId}`: ゲーム状態（プレイヤー一覧、手札/場の状態、現在のターン、status）を返す。
   - POST `/darour/{gameId}/deal`（任意）: 初期配布・開始用（サーバ側で手札をシャッフルして配る）。
   - POST `/darour/{gameId}/move` / `/forfeit` は後回しでも良い（まずはマッチングと画面遷移を優先）。

3. 永続化の選択肢
   - 最少工数: in‑memory（MatchService）でマッチングとゲームセッションを保持。開発／動作確認が容易。
   - 拡張: `schema.sql` に `darour_game` / `darour_move` を追加し、Mapper を用いて永続化する（既存 gomoku/marubatsu と同様）。

4. フロント実装
   - 既存の `matching.html` フローを利用。`templates/dairo.html`（既存）に data 属性で game 名を埋め、`/matching/status?game=dairo` をポーリングする実装を流用。
   - ゲーム画面では `/darour/{gameId}` をポーリングして初期手札やターン情報を取得する（まずは表示のみ）。

## 必要な具体的変更点（短期）
- `MatchingController.java` に darour 分岐（待機人数判定、先頭 N 名を MATCHED に更新、MatchService#createMatch を呼ぶ）。
- `MatchService` の `createMatch` を 3 人対応に軽微変更するか、darour 用に別の create メソッドを追加。
- `DarourController` を REST 形式で拡張（GET `/darour/{gameId}`）または新たに `DarourGameController` を作成。
- フロント: `templates/dairo.html` に polling ロジック（既存ページの例を流用）。

## リスクと注意点
- Darour は 3 人ゲームのため、既存の 2 人想定のコード（MatchService の player1/player2 固定等）をそのまま流用できない箇所がある。Match 型やサービスの設計を 3 人対応に拡張する必要がある。
- ゲーム進行（ターン管理、勝敗判定、カード配布の一意性）は Darour 特有のロジックが必要。MVP では最初に「表示のみ」で配布した手札をプレイヤに見せる流れから始めることを推奨する。
- 永続化を行う場合、`schema.sql` の変更・Mapper の追加・マイグレーションが必要になる。まずは in‑memory で検証してから永続化へ移行すると変更範囲を小さくできる。

## 推奨する次のアクション（短期）
1. まずは最小パッチとして `MatchingController` に darour 用の待機判定を追加し、MatchService（in‑memory）で gameId を作成して返す実装を行う（優先度高）。
2. 次に `DarourGameController`（または現在の DarourController を拡張）で GET `/darour/{gameId}` を実装し、ブラウザで初期手札を表示できるようにする。
3. 動作確認後、必要に応じて `schema.sql` に `darour_game` 定義と Mapper を追加して永続化へ移行する。

---
作成者: 自動調査エージェント
作成日: 2025-12-22

作業報告: 本ファイルを `docs/reports/investigate/2025-12-22_darour_マッチング実装調査.md` として作成しました。次に実装パッチを希望する場合は「実装」を指示してください。
